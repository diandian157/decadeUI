import{game,_status,lib}from"noname";import{delayRemoveCards as e,getMapElementPos as t,getRandom as i,isMobile as a}from"../utils/core.js";import{getPlayerIdentity as r}from"../utils/identity.js";import{BoundsCache as s,createBoundsCaches as o}from"../utils/bounds.js";import{element as u}from"../utils/element.js";import{layoutHandDraws as n,layoutDrawCards as c}from"../ui/layout-utils.js";import{cardTempSuitNum as d,tryAddPlayerCardUseTag as l}from"../ui/card-utils.js";import{showHandTip as m}from"../ui/handtip.js";const h=s=>{Object.assign(s,{isMobile:a,getRandom:i,getMapElementPos:t,delayRemoveCards:e,getPlayerIdentity:r}),s.delay=e=>{if("number"!=typeof e)throw new Error("milliseconds must be a number");_status.paused||(game.pause(),_status.timeout=setTimeout(game.resume,e))},s.queueNextTick=(e,t)=>{s._tickEntries??=[],s._tickEntries.push({ctx:t,callback:e}),s._queueTick||(s._queueTick=Promise.resolve().then(()=>{s._queueTick=null;const e=s._tickEntries;s._tickEntries=[],e.forEach(e=>e.callback.call(e.ctx))}))},s.queueNextFrameTick=(e,t)=>{s._frameTickEntries??=[],s._frameTickEntries.push({ctx:t,callback:e}),s._queueFrameTick||(s._queueFrameTick=requestAnimationFrame(()=>{s._queueFrameTick=null;const e=s._frameTickEntries;s._frameTickEntries=[],setTimeout(()=>e.forEach(e=>e.callback.call(e.ctx)),0)}))},s.layoutHand=()=>s.layout.updateHand(),s.layoutHandDraws=e=>n(e,s.boundsCaches),s.layoutDrawCards=(e,player,t)=>c(e,player,t,s.boundsCaches),s.layoutDiscard=()=>s.layout.updateDiscard(),s.cardTempSuitNum=(card,e,t)=>d(card,e,t,s.element),s.tryAddPlayerCardUseTag=(card,player,event)=>l(card,player,event,s);s.getCardBestScale=e=>(e=e?.height?e:s.getHandCardSize(),Math.min(s.get.bodySize().height*(lib.config?.extension_十周年UI_cardScale??.18)/e.height,1)),s.getHandCardSize=(e=!1)=>{const t=s.sheet.getStyle(".media_defined > .card")||s.sheet.getStyle(".hand-cards > .handcards > .card");return t?{width:parseFloat(t.width),height:parseFloat(t.height)}:e?{width:108,height:150}:{width:0,height:0}}},p=e=>{e.BoundsCache=s,e.boundsCaches=o(e),e.element=u,e.showHandTip=t=>m(t,e),e.game={wait:game.pause,resume(){if(game.loopLocked)return void(_status.paused=!1);const t=e.eventDialog;!1!==t?.finished||t.finishing?game.resume():(t.finish(),e.eventDialog=void 0)}}};export{p as enhanceDecadeUIRuntime,h as registerDecadeUIUtilityModule};
